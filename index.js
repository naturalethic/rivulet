// Generated by LiveScript 1.4.0
(function(){
  var kefir, patch, objectPath, toString$ = {}.toString;
  kefir = require('kefir');
  patch = require('fast-json-patch');
  objectPath = require('object-path');
  module.exports = function(socket, channel){
    var state, observers, emitQueue, rivulet, emitStream;
    state = {};
    observers = {
      atom: {},
      flat: {},
      deep: {}
    };
    emitQueue = [];
    rivulet = function(it){
      if (it) {
        return rivulet.patch(patch.compare(state, it));
      } else {
        return JSON.parse(JSON.stringify(state));
      }
    };
    import$(rivulet, {
      logger: null,
      get: function(path){
        return objectPath.get(state, path);
      },
      set: function(path, val){
        var revised;
        revised = rivulet();
        objectPath.set(revised, path, val);
        return rivulet(revised);
      },
      del: function(path){
        var revised;
        revised = rivulet();
        objectPath.del(revised, path);
        return rivulet(revised);
      },
      observe: function(path, func, depth){
        depth == null && (depth = 'flat');
        if (!observers[depth][path]) {
          observers[depth][path] = {};
          observers[depth][path].stream = kefir.stream(function(it){
            return observers[depth][path].emitter = it;
          });
        }
        if (func) {
          observers[depth][path].stream.onValue(function(){
            return setTimeout(function(){
              return func(rivulet());
            });
          });
        }
        return observers[depth][path].stream;
      },
      observeAtom: function(path, func){
        return rivulet.observe(path, func, 'atom');
      },
      observeFlat: function(path, func){
        return rivulet.observe(path, func, 'flat');
      },
      observeDeep: function(path, func){
        return rivulet.observe(path, func, 'deep');
      },
      patch: function(diff, emit){
        var deepEmits, flatEmits, emitChange, i$, len$, change, results$ = [];
        emit == null && (emit = true);
        if (!diff.length) {
          return;
        }
        if (emit) {
          emitQueue.push(diff);
        }
        deepEmits = [];
        flatEmits = [];
        patch.apply(state, diff);
        emitChange = function(change){
          var changePath, path, ref$, observer, key, val, i$, len$, results$ = [];
          changePath = compact(change.path.split('/')).join('.');
          if (observers.atom[changePath]) {
            observers.atom[changePath].emitter.emit(changePath);
          }
          for (path in ref$ = observers.deep) {
            observer = ref$[path];
            if (in$(path, deepEmits)) {
              continue;
            }
            if (RegExp(path + '').test(changePath)) {
              observer.emitter.emit(path);
              deepEmits.push(path);
            }
          }
          for (path in ref$ = observers.flat) {
            observer = ref$[path];
            if (in$(path, flatEmits)) {
              continue;
            }
            if (RegExp('^' + path + '(\\.[^\\.]+)?$').test(changePath)) {
              observer.emitter.emit(path);
              flatEmits.push(path);
            }
          }
          if (change.op === 'add' && toString$.call(change.value).slice(8, -1) === 'Object') {
            for (key in ref$ = change.value) {
              val = ref$[key];
              emitChange({
                op: 'add',
                path: change.path + ("/" + key),
                value: val
              });
            }
          }
          if (change.op === 'add' && toString$.call(change.value).slice(8, -1) === 'Array') {
            for (i$ = 0, len$ = (ref$ = change.value).length; i$ < len$; ++i$) {
              key = i$;
              val = ref$[i$];
              results$.push(emitChange({
                op: 'add',
                path: change.path + ("/" + key),
                value: val
              }));
            }
            return results$;
          }
        };
        for (i$ = 0, len$ = diff.length; i$ < len$; ++i$) {
          change = diff[i$];
          results$.push(emitChange(change));
        }
        return results$;
      },
      merge: function(partial){
        var revised;
        revised = import$(rivulet(), partial);
        return rivulet(revised);
      }
    });
    if (socket && channel) {
      rivulet.socket = socket;
      rivulet.socket.on(channel, function(it){
        if (rivulet.logger) {
          rivulet.logger('Rivulet received', it);
        }
        return rivulet.patch(it, false);
      });
      emitStream = rivulet.observeDeep('');
      emitStream.onValue(function(){
        var diff, results$ = [];
        while (diff = emitQueue.pop()) {
          if (rivulet.logger) {
            rivulet.logger('Rivulet sending', diff);
          }
          results$.push(socket.emit(channel, diff));
        }
        return results$;
      });
    }
    return rivulet;
  };
  function import$(obj, src){
    var own = {}.hasOwnProperty;
    for (var key in src) if (own.call(src, key)) obj[key] = src[key];
    return obj;
  }
  function in$(x, xs){
    var i = -1, l = xs.length >>> 0;
    while (++i < l) if (x === xs[i]) return true;
    return false;
  }
}).call(this);
